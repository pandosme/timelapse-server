//Copyright (c) 2021 Fred Juhlin

const VapixWrapper = require('vapix-wrapper');

module.exports = function(RED) {
	
    function Axis_Device(config) {
		RED.nodes.createNode(this,config);
		this.preset = config.preset;
		this.action = config.action;
		this.cgi = config.cgi;
		this.data = config.data;
		this.options = config.options;
		this.filename = config.filename;
		var node = this;
		node.on('input', function(msg) {
			node.status({});

			var device = {
				address: null,
				user: null,
				password: null,
				protocol: "http"
			}

			var preset = RED.nodes.getNode(node.preset);
			if( preset ) {
				device.address = preset.address;
				device.user = preset.credentials.user;
				device.password = preset.credentials.password;
				device.protocol = preset.protocol || "http";
			}
			if( msg.address ) device.address = msg.address;
			if( msg.user ) device.user = msg.user;
			if( msg.password ) device.password = msg.password;

			var action = msg.action || node.action;
			var data = node.data || msg.payload;
			var options = msg.options || node.options;
			var filename = msg.filename || node.filename;
			
			msg.error = false;
			
			switch( action ) {
				case "Device Info":
					VapixWrapper.DeviceInfo( device, function(error, response ) {
						msg.error = error;
						msg.payload = response;
						node.send(msg);
					});
				break;

				case "Network settings":
					var request = {
						"apiVersion": "1.0",
						"context": "nodered",
						"method": "getNetworkInfo",
						"params":{}
					}
					VapixWrapper.CGI_Post( device, "/axis-cgi/network_settings.cgi", request, function(error, response ) {
						msg.error = error;
						msg.payload = response;
						if( typeof msg.payload === "string" ) { 
							var json = JSON.parse(response);
							if( json )
								msg.payload = json;
						}
						msg.payload.hasOwnProperty("error")
							msg.error = msg.payload.error;
						msg.payload.hasOwnProperty("data")
							msg.payload = msg.payload.data;
						node.send(msg);
					});
				break;
				
				case "Restart":
					VapixWrapper.CGI( device, '/axis-cgi/restart.cgi', function(error, response) {
						msg.error = error;
						msg.payload = response;
						if( error ) {
							node.send(msg);
							return;
						}
						node.send(msg);
						msg.payload = "Device restarting...";
					});
				break;

				case "Upgrade firmware":
					var firmware = filename || msg.payload
					node.status({fill:"blue",shape:"dot",text:"Updating firmware..."});
					VapixWrapper.Upload_Firmare( device , firmware, function(error, response ) {
						msg.payload = response;
						msg.error = error;
						if(msg.error) {
							node.status({fill:"red",shape:"dot",text:"Device upgrade failed"});
						} else {
							node.status({fill:"green",shape:"dot",text:"Device upgrade success"});
							msg.payload = "Device upgraded and restarted";
						}
						node.send(msg);
					});
				break;
				
				case "HTTP Get":
					var cgi = node.cgi || msg.cgi;
					if( !cgi || cgi.length < 2 ) {
						msg.error = "Invalid input";
						msg.payload = "Invalid CGI";
						return;
					}
					VapixWrapper.HTTP_Get( device, cgi, "text", function(error, response ) {

						msg.error = error;
						msg.payload = response;
						if( typeof msg.payload === "string") {
							if( msg.payload[0] === '{' || msg.payload[0] === '[' ) {
								var json = JSON.parse(response);
								if( json )
									msg.payload = json;
							}
						}
						node.send(msg);
					});
				break;
				
				case "HTTP Post":
					var cgi = node.cgi || msg.cgi;
					if( !cgi || cgi.length < 2 ) {
						msg.error = "Invalid input";
						msg.payload = "Invalid VAPIX CGI";
						return;
					}
					if(!data) {
						msg.error = "Invalid input";
						msg.payload = "No payload";
						node.send(msg);
						return;
					}
					node.status({fill:"blue",shape:"dot",text:"Requesting..."});
					VapixWrapper.HTTP_Post( device, cgi, data, "text", function(error, response ) {
						msg.error = error;
						if( error )
							node.status({fill:"red",shape:"dot",text:"Request failed"});
						else
							node.status({fill:"green",shape:"dot",text:"Request success"});
						if( typeof response === "string" && (response[0] === '{' << response[0] === '[') )
							msg.payload =  JSON.parse(response);
						else
							msg.payload = response;
						node.send(msg);
					});
				break;

				case "SOAP Post":
					if( typeof data !== "string" || data.length < 20 || data[0] !== '<') {
						msg.error = "Invalid input";
						msg.payload = "Check SOAP Body syntax";
					}
					VapixWrapper.SOAP( device, data, function(error, response ) {
						msg.error = error;
						msg.payload = response;
						node.send(msg);
					});
				break;

				case "Set time":
					if( typeof options === "string" )
						options = JSON.parse(options);

					if(!options) {
						msg.error = "Invalid input";
						msg.payload = "Set time options";
						node.send(msg);
						return;
					}
					var numberOfSetttings = 0;
					for( var name in options ) {
						if(name === "ntp")
							numberOfSetttings++;
						if(name === "timezone")
							numberOfSetttings++;
					}
					if( numberOfSetttings === 0 ) {
						msg.error = false;
						msg.payload = "OK";
						node.send(msg);
						return;
					}
					if( options.hasOwnProperty("ntp") ) {
						if(typeof options.ntp === "string" )
							options.ntp = [options.ntp];
						if( !Array.isArray(options.ntp) ) {
							VapixWrapper.CGI( device, "/axis-cgi/param.cgi?action=update&Time.ObtainFromDHCP=yes", function(error, response ){
								numberOfSetttings--;
								if( numberOfSetttings <= 0 ) {
									if(!error)
										msg.payload = "OK";
									node.send(msg);
									return;
								}
							});
						} else {
							var body = {
								"apiVersion":"1.1",
								"method":"setNTPClientConfiguration",
								"params":{
									"enabled":true,
									"serversSource":"static",
									"staticServers":options.ntp
								}
							}
							VapixWrapper.CGI_Post( device, "/axis-cgi/ntp.cgi", body, function(error, response) {
								msg.error = error;
								msg.payload = response;
								if( error ) {
									numberOfSetttings--;
									if( numberOfSetttings <= 0 ) {
										node.send(msg);
										return;
									}
								}
								VapixWrapper.CGI( device, "/axis-cgi/param.cgi?action=update&Time.ObtainFromDHCP=no", function(error, response ){
									msg.error = error;
									msg.payload = response;
									numberOfSetttings--;
									if( numberOfSetttings <= 0 ) {
										if(!error)
											msg.payload = "OK";
										node.send(msg);
										return;
									}
								})
							});
						}
					}
					if( options.hasOwnProperty("timezone") ) {
						if( typeof options.timezone !== "string" || options.timezone.length < 8 ||  options.timezone.search("/") < 0 ) {
							numberOfSetttings--;
							if( numberOfSetttings <= 0 ) {
								msg.error = "Invalid input";
								msg.payload = "Timezon syntax";
								node.send(msg);
							}
						} else {
							var body = {
								"apiVersion":"1.0",
								"method":"setTimeZone",
								"params":{
									"timeZone": options.timezone
								}
							}
							VapixWrapper.CGI_Post( device, "/axis-cgi/time.cgi", body, function(error, response) {
								msg.error = error;
								msg.payload = response;
								if(!error)
									msg.payload = "OK";
								numberOfSetttings--;
								if( numberOfSetttings <= 0 ) {
									node.send(msg);
								}
							});
						}
					}
				break;

				case "Syslog":
					VapixWrapper.Syslog( device, function( error, response) {
						msg.payload = response;
						msg.error = error;
						node.send(msg);
					});
				break;

				case "Connections":
					VapixWrapper.Connections( device, function( error, response) {
						msg.payload = response;
						msg.error = error;
						node.send(msg);
					});
				break;

				case "Get location":
					VapixWrapper.Location_Get( device, function( error, response) {
						msg.payload = response;
						msg.error = error;
						node.send(msg);
					});
				break;

				case "Set location":
					if( typeof options === "string" )
						options = JSON.parse( options );
					
					if(!options || typeof options !== "object") {
						msg.error = "Invalid input";
						msg.payload = "Check location syntax";
						node.send(msg);
						return;
					}
					VapixWrapper.Location_Set( device, options, function( error, response) {
						msg.payload = response;
						msg.error = error;
						node.send(msg);
					});
				break;
				
				default:
					msg.error = "Invalid input";
					msg.payload = "Action " + action + " is undefined";
					node.send(msg);
					return;
			}
        });
    }
	
    RED.nodes.registerType("axis-device",Axis_Device,{
		defaults: {
			name: { type:"text" },
			preset: {type:"axis-preset"},
			action: { type:"text" },
			data: {type: "text"},
			options: {type: "text"},
			cgi: {type: "text"},
			filename: { type:"text" }
		}		
	});
}

